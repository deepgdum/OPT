{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": None,
   "id": "404fc4e2-004d-4d91-b9c6-434c3faf3c6d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Save this as `portfolio_optimization.py`\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import yfinance as yf\n",
    "import cvxpy as cp\n",
    "import streamlit as st\n",
    "import plotly.express as px\n",
    "from datetime import datetime, timedelta\n",
    "\n",
    "# 1. Fetch Real-Time Stock Data with Error Handling\n",
    "def get_stock_data(tickers, start, end):\n",
    "    try:\n",
    "        data = yf.download(tickers, start=start, end=end)['Adj Close']\n",
    "        if data is None or data.empty:\n",
    "            st.error(\"No data found for the given tickers and date range.\")\n",
    "            return None, None\n",
    "        returns = data.pct_change().dropna()\n",
    "        return data, returns\n",
    "    except Exception as e:\n",
    "        st.error(f\"Error fetching stock data: {e}\")\n",
    "        return None, None\n",
    "\n",
    "# 2. Calculate Expected Returns & Covariance Matrix\n",
    "def calculate_metrics(returns):\n",
    "    if returns is None or returns.empty:\n",
    "        return None, None\n",
    "    mu = returns.mean()  # Expected returns\n",
    "    sigma = returns.cov()  # Covariance matrix\n",
    "    return mu, sigma\n",
    "\n",
    "# 3. Portfolio Optimization with Error Handling\n",
    "def optimize_portfolio(mu, sigma, prev_weights=None, risk_aversion=0.5, short_selling=False, transaction_cost=0.001):\n",
    "    if mu is None or sigma is None:\n",
    "        return None\n",
    "    try:\n",
    "        n = len(mu)\n",
    "        w = cp.Variable(n)\n",
    "        objective = cp.Maximize(mu.T @ w - risk_aversion * cp.quad_form(w, sigma))\n",
    "        constraints = [cp.sum(w) == 1]\n",
    "        if not short_selling:\n",
    "            constraints.append(w >= 0)\n",
    "        \n",
    "        if prev_weights is not None:\n",
    "            trade_cost = cp.norm(w - prev_weights, 1) * transaction_cost\n",
    "            objective -= trade_cost \n",
    "        \n",
    "        problem = cp.Problem(objective, constraints)\n",
    "        problem.solve()\n",
    "        \n",
    "        if w.value is None:\n",
    "            st.error(\"Optimization failed. Check input parameters.\")\n",
    "            return None\n",
    "        return w.value\n",
    "    except Exception as e:\n",
    "        st.error(f\"Optimization error: {e}\")\n",
    "        return None\n",
    "\n",
    "# 4. Risk-Adjusted Metrics (Sharpe Ratio)\n",
    "def calculate_sharpe_ratio(portfolio_returns, risk_free_rate=0.02):\n",
    "    if portfolio_returns is None or portfolio_returns.empty:\n",
    "        return None\n",
    "    excess_returns = portfolio_returns - risk_free_rate\n",
    "    return np.mean(excess_returns) / np.std(excess_returns) if np.std(excess_returns) > 0 else None\n",
    "\n",
    "# 5. Trigger-Based Rebalancing with Safe Handling\n",
    "def trigger_rebalancing(tickers, start, end, initial_capital=100000, risk_aversion=0.5, transaction_cost=0.001, weight_deviation_threshold=0.05):\n",
    "    data, returns = get_stock_data(tickers, start, end)\n",
    "    if data is None or returns is None:\n",
    "        return None, None, None, None, None\n",
    "    \n",
    "    mu, sigma = calculate_metrics(returns)\n",
    "    if mu is None or sigma is None:\n",
    "        return None, None, None, None, None\n",
    "    \n",
    "    dates = data.index\n",
    "    portfolio_weights = {}\n",
    "    prev_weights = None\n",
    "    portfolio_values = []\n",
    "    capital = initial_capital\n",
    "    transaction_costs = []\n",
    "    rebalance_dates = []\n",
    "    \n",
    "    for date in dates:\n",
    "        if prev_weights is None:\n",
    "            opt_weights = optimize_portfolio(mu, sigma, prev_weights, risk_aversion, transaction_cost=transaction_cost)\n",
    "            if opt_weights is None:\n",
    "                return None, None, None, None, None\n",
    "            portfolio_weights[date] = opt_weights\n",
    "            prev_weights = opt_weights\n",
    "            rebalance_dates.append(date)\n",
    "        else:\n",
    "            if date not in returns.index:\n",
    "                continue\n",
    "            \n",
    "            current_weights = prev_weights * (1 + returns.loc[date])\n",
    "            current_weights /= np.sum(current_weights)\n",
    "            \n",
    "            deviation = np.abs(current_weights - prev_weights)\n",
    "            if np.any(deviation > weight_deviation_threshold):\n",
    "                opt_weights = optimize_portfolio(mu, sigma, prev_weights, risk_aversion, transaction_cost=transaction_cost)\n",
    "                if opt_weights is None:\n",
    "                    return None, None, None, None, None\n",
    "                portfolio_weights[date] = opt_weights\n",
    "                prev_weights = opt_weights\n",
    "                rebalance_dates.append(date)\n",
    "            else:\n",
    "                portfolio_weights[date] = current_weights\n",
    "                prev_weights = current_weights\n",
    "        \n",
    "        capital *= (1 + np.dot(prev_weights, returns.loc[date]))\n",
    "        portfolio_values.append(capital)\n",
    "        \n",
    "        if len(rebalance_dates) > 1 and date == rebalance_dates[-1]:\n",
    "            trade_cost = np.sum(np.abs(portfolio_weights[date] - portfolio_weights[rebalance_dates[-2]])) * transaction_cost\n",
    "            transaction_costs.append(trade_cost)\n",
    "        else:\n",
    "            transaction_costs.append(0)\n",
    "    \n",
    "    portfolio_returns = pd.Series(portfolio_values).pct_change().dropna()\n",
    "    sharpe_ratio = calculate_sharpe_ratio(portfolio_returns)\n",
    "    \n",
    "    return portfolio_weights, portfolio_values, transaction_costs, sharpe_ratio, rebalance_dates\n",
    "\n",
    "# 6. Visualization Dashboard with None Checks\n",
    "def portfolio_dashboard(portfolio_values, dates, transaction_costs, sharpe_ratio, rebalance_dates):\n",
    "    st.title(\"ðŸ“ˆ Trigger-Based Portfolio Optimization Dashboard\")\n",
    "    \n",
    "    if portfolio_values is None or len(portfolio_values) == 0:\n",
    "        st.error(\"No portfolio values available for visualization.\")\n",
    "        return\n",
    "    \n",
    "    # Portfolio Performance Chart\n",
    "    df = pd.DataFrame({\"Date\": dates, \"Portfolio Value\": portfolio_values})\n",
    "    fig1 = px.line(df, x=\"Date\", y=\"Portfolio Value\", title=\"Portfolio Performance Over Time\", labels={\"Portfolio Value\": \"Portfolio Value ($)\"})\n",
    "    fig1.update_layout(showlegend=False, xaxis_title=\"Date\", yaxis_title=\"Portfolio Value ($)\", template=\"plotly_dark\")\n",
    "    st.plotly_chart(fig1)\n",
    "    \n",
    "    # Transaction Costs Chart\n",
    "    df_costs = pd.DataFrame({\"Date\": dates, \"Transaction Cost\": transaction_costs})\n",
    "    fig2 = px.bar(df_costs, x=\"Date\", y=\"Transaction Cost\", title=\"Transaction Costs Over Time\", labels={\"Transaction Cost\": \"Transaction Cost ($)\"})\n",
    "    fig2.update_layout(xaxis_title=\"Date\", yaxis_title=\"Transaction Cost ($)\", template=\"plotly_dark\")\n",
    "    st.plotly_chart(fig2)\n",
    "    \n",
    "    # Rebalancing Events Chart\n",
    "    df_rebalance = pd.DataFrame({\"Date\": rebalance_dates, \"Event\": [\"Rebalance\"] * len(rebalance_dates)})\n",
    "    fig3 = px.scatter(df_rebalance, x=\"Date\", y=[0] * len(rebalance_dates), title=\"Rebalancing Events\", labels={\"Date\": \"Rebalance Date\"})\n",
    "    fig3.update_layout(showlegend=False, xaxis_title=\"Date\", yaxis_title=\"Event\", template=\"plotly_dark\")\n",
    "    st.plotly_chart(fig3)\n",
    "    \n",
    "    # Sharpe Ratio\n",
    "    if sharpe_ratio is not None:\n",
    "        st.metric(\"ðŸ“Š Sharpe Ratio\", f\"{sharpe_ratio:.2f}\")\n",
    "    else:\n",
    "        st.error(\"Unable to calculate Sharpe Ratio.\")\n",
    "\n",
    "# 7. Main Function with Safe Execution\n",
    "def main():\n",
    "    st.sidebar.title(\"Portfolio Optimization Parameters\")\n",
    "    tickers = st.sidebar.text_input(\"Enter Tickers (comma-separated)\", \"AAPL,MSFT,GOOGL,TSLA,AMZN\").split(',')\n",
    "    start_date = st.sidebar.date_input(\"Start Date\", datetime.now() - timedelta(days=365))\n",
    "    end_date = st.sidebar.date_input(\"End Date\", datetime.now())\n",
    "    risk_aversion = st.sidebar.slider(\"Risk Aversion\", 0.0, 1.0, 0.5, 0.01)\n",
    "    \n",
    "    st.sidebar.info(\"ðŸ”§ Adjust settings and press 'Run Optimization' to trigger portfolio analysis.\")\n",
    "    \n",
    "    if st.sidebar.button(\"Run Optimization\"):\n",
    "        portfolio, portfolio_values, transaction_costs, sharpe_ratio, rebalance_dates = trigger_rebalancing(\n",
    "            tickers, start_date.strftime('%Y-%m-%d'), end_date.strftime('%Y-%m-%d'), risk_aversion=risk_aversion\n",
    "        )\n",
    "        \n",
    "        if portfolio_values:\n",
    "            dates = pd.date_range(start_date, end_date, freq='D')[:len(portfolio_values)]\n",
    "            portfolio_dashboard(portfolio_values, dates, transaction_costs, sharpe_ratio, rebalance_dates)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
